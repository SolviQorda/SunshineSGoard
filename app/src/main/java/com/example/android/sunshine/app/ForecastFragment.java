package com.example.android.sunshine.app;/** * Created by sorengoard on 29/07/16. */import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Intent;import android.content.SharedPreferences;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.preference.PreferenceManager;import android.support.v4.app.Fragment;import android.support.v4.app.LoaderManager;import android.support.v4.content.CursorLoader;import android.support.v4.content.Loader;import android.util.Log;import android.view.LayoutInflater;import android.view.Menu;import android.view.MenuInflater;import android.view.MenuItem;import android.view.View;import android.view.ViewGroup;import android.widget.AdapterView;import android.widget.ListView;import android.widget.TextView;import com.example.android.sunshine.app.data.WeatherContract;import com.example.android.sunshine.app.sync.SunshineSyncAdapter;/** * A placeholder fragment containing a simple view. */public class ForecastFragment extends Fragment implements LoaderManager.LoaderCallbacks<Cursor>, SharedPreferences.OnSharedPreferenceChangeListener {    private AlarmManager alrmManager;    private PendingIntent alarmIntent;    private ForecastAdapter mForecastAdapter;    private ListView mListView;    private int mPosition = ListView.INVALID_POSITION;    private static final String LOG_TAG = ForecastFragment.class.getSimpleName();    private boolean mUseTodayLayout = true;    private static final String SELECTED_KEY = "selected_position";    private static final int FORECAST_LOADER = 0;    private static final String[] FORECAST_COLUMNS = {            // In this case the id needs to be fully qualified with a table name, since            // the content provider joins the location & weather tables in the background            // (both have an _id column)            // On the one hand, that's annoying.  On the other, you can search the weather table            // using the location set by the user, which is only in the Location table.            // So the convenience is worth it.            WeatherContract.WeatherEntry.TABLE_NAME + "." + WeatherContract.WeatherEntry._ID,            WeatherContract.WeatherEntry.COLUMN_DATE,            WeatherContract.WeatherEntry.COLUMN_SHORT_DESC,            WeatherContract.WeatherEntry.COLUMN_MAX_TEMP,            WeatherContract.WeatherEntry.COLUMN_MIN_TEMP,            WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING,            WeatherContract.WeatherEntry.COLUMN_WEATHER_ID,            WeatherContract.LocationEntry.COLUMN_LATITUDE,            WeatherContract.LocationEntry.COLUMN_LONGITUDE    };    static final int COL_WEATHER_ID = 0;    static final int COL_WEATHER_DATE = 1;    static final int COL_WEATHER_DESC = 2;    static final int COL_WEATHER_MAX_TEMP = 3;    static final int COL_WEATHER_MIN_TEMP = 4;    static final int COL_LOCATION_SETTING = 5;    static final int COL_WEATHER_CONDITION_ID = 6;    static final int COL_COORD_LAT = 7;    static final int COL_COORD_LONG = 8;    public interface Callback {        public void onItemSelected(Uri dateUri);    }    public ForecastFragment() {    }    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setHasOptionsMenu(true);    }    @Override    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {        inflater.inflate(R.menu.forecastfragment, menu);    }    @Override    public void onResume(){        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());        prefs.registerOnSharedPreferenceChangeListener(this);        super.onResume();    }    @Override    public void onPause() {        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());        prefs.unregisterOnSharedPreferenceChangeListener(this);        super.onPause();    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        int id = item.getItemId();//        if (id == R.id.action_refresh) {//            updateWeather();//            return true;        if(id == R.id.action_map) {            openPreferredLocationInMap();            return true;        }//        else if (id == R.id.action_settings) {//            Intent settingsIntent = new Intent(getActivity(), SettingsActivity.class);//            ForecastFragment.this.startActivity(settingsIntent);//            return true;//        }        return super.onOptionsItemSelected(item);    }    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        mForecastAdapter = new ForecastAdapter(getActivity(), null, 0);        View rootView = inflater.inflate(R.layout.fragment_main, container, false);        mListView = (ListView) rootView.findViewById(R.id.listview_forecast);        View emptyView = rootView.findViewById(R.id.listview_forecast_empty);        mListView.setEmptyView(emptyView);        mListView.setAdapter(mForecastAdapter);        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener()        {            @Override            public void onItemClick(AdapterView<?> adapterView, View view, int position, long l)            {                // CursorAdapter returns a cursor at the correct position for getItem(), or null                // if it cannot seek to that position.                Cursor cursor = (Cursor) adapterView.getItemAtPosition(position);                if(cursor != null)                {                    String locationSetting = Utility.getPreferredLocation(getActivity());                    ((Callback) getActivity())                            .onItemSelected(WeatherContract.WeatherEntry.buildWeatherLocationWithDate(                                    locationSetting, cursor.getLong(COL_WEATHER_DATE)                            ));                }                mPosition = position;            }        });        // If there's instance state, mine it for useful information.      // The end-goal here is that the user never knows that turning their device sideways         // does crazy lifecycle related things.  It should feel like some stuff stretched out,         // or magically appeared to take advantage of room, but data or place in the app was never        // actually *lost*.        if(savedInstanceState != null && savedInstanceState.containsKey(SELECTED_KEY))        {            mPosition =savedInstanceState.getInt(SELECTED_KEY);        }        mForecastAdapter.setUseTodayLayout(mUseTodayLayout);        return rootView;    }    private void updateWeather() {////        Intent alarmIntent = new Intent(getActivity(), SunshineService.AlarmReceiver.class);////        alarmIntent.putExtra(SunshineService.LOCATION_QUERY_EXTRA,//                Utility.getPreferredLocation(getActivity()));////        PendingIntent pi = PendingIntent.getBroadcast(getActivity(), 0, alarmIntent, PendingIntent.FLAG_ONE_SHOT);////        alrmManager = (AlarmManager)getActivity().getSystemService(Context.ALARM_SERVICE);////        alrmManager.set(AlarmManager.RTC_WAKEUP,//                System.currentTimeMillis() + 5000, pi);        SunshineSyncAdapter.syncImmediately(getActivity());    }    private void openPreferredLocationInMap(){        // Using the URI scheme for showing a location found on a map.  This super-handy        // intent can is detailed in the "Common Intents" page of Android's developer site:        // http://developer.android.com/guide/components/intents-common.html#Maps        if (null != mForecastAdapter) {            Cursor c = mForecastAdapter.getCursor();            if(null != c){                c.moveToPosition(0);                String posLat = c.getString(COL_COORD_LAT);                String posLong = c.getString(COL_COORD_LAT);                Uri geolocation = Uri.parse("geo:" + posLat + "," + posLong);                Intent intent = new Intent(Intent.ACTION_VIEW);                intent.setData(geolocation);                if(intent.resolveActivity(getActivity().getPackageManager()) != null) {                    startActivity(intent);                } else {                    Log.d(LOG_TAG, "couldn't call: " + geolocation.toString() + ", no recieving apps installed!");                }            }        }    }    @Override    public void onActivityCreated(Bundle savedInstanceState) {        getLoaderManager().initLoader(FORECAST_LOADER, null, this);        super.onActivityCreated(savedInstanceState);    }    @Override    public void onSaveInstanceState(Bundle outState)    {        if(mPosition != ListView.INVALID_POSITION)        {            outState.putInt(SELECTED_KEY, mPosition);        }        super.onSaveInstanceState(outState);    }    @Override    public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {        String locationSetting = Utility.getPreferredLocation(getActivity());        String sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + " ASC";        Uri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(                locationSetting, System.currentTimeMillis());        return new CursorLoader(getActivity(),                weatherForLocationUri,                FORECAST_COLUMNS,                null,                null,                sortOrder);    }    @Override    public void onLoadFinished(Loader<Cursor> cursorLoader, Cursor cursor) {        mForecastAdapter.swapCursor(cursor);        if(mPosition != ListView.INVALID_POSITION) {            mListView.smoothScrollToPosition(mPosition);        }        updateEmptyView();    }    @Override    public void onLoaderReset(Loader<Cursor> loader)    {        mForecastAdapter.swapCursor(null);    }    void onLocationChanged()    {        updateWeather();        getLoaderManager().restartLoader(FORECAST_LOADER, null, this);    }    public void setUseTodayLayout(boolean useTodayLayout){        mUseTodayLayout = useTodayLayout;        if(mForecastAdapter != null) {            mForecastAdapter.setUseTodayLayout(mUseTodayLayout);        }    }    private void updateEmptyView() {        if(mForecastAdapter.getCount() == 0){            TextView tv = (TextView)getView().findViewById(R.id.listview_forecast_empty);            if (tv != null) {                int message = R.string.no_weather_info;                @SunshineSyncAdapter.LocationStatus int locationStatus = Utility.getLocationStatus(getActivity());                switch (locationStatus){                    case SunshineSyncAdapter.LOCATION_STATUS_SERVER_DOWN:                        message=R.string.empty_forecast_list_server_down;                        break;                    case SunshineSyncAdapter.LOCATION_STATUS_SERVER_INVALID:                        message=R.string.empty_forecast_list_server_error;                        break;                    case SunshineSyncAdapter.LOCATION_STATUS_INVALID:                        message=R.string.empty_forecast_list_invalid_location;                        break;                    default:                        if(!Utility.isConnected(getActivity())) {                            message = R.string.no_network_info;                        }                }                tv.setText(message);            }        }    }    @Override    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {        if(key.equals(getString(R.string.pref_loc_status_key))) {            updateEmptyView();        }    }}